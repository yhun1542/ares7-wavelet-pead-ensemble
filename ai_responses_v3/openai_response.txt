To address the problem of reducing the Maximum Drawdown (MDD) while maintaining or improving the Sharpe ratio and annualized returns, let's break down the situation, analyze potential causes, and propose actionable techniques.

### Root Cause Analysis

1. **High Leverage**: The use of Kelly Criterion dynamic leverage up to 2.0x can amplify both returns and losses. This leverage might contribute to higher drawdowns during adverse market moves.

2. **Momentum Overlay**: While momentum can enhance returns, it can also increase volatility during regime changes, leading to larger drawdowns.

3. **Regime Detection Lag**: If regime detection is not timely, the system might not adjust positions quickly enough during market downturns, exacerbating drawdowns.

### Specific Actionable Techniques

1. **Adaptive Leverage Control**: Implement a volatility-adjusted leverage cap to dynamically reduce leverage when market volatility increases, thus reducing drawdown risk.

2. **Enhanced Regime Detection with Machine Learning**: Utilize ML techniques like random forests or gradient boosting for better regime detection. This can help identify transitioning market phases more accurately, allowing for timely adjustments.

3. **Diversification with Uncorrelated Assets**: Introduce a basket of uncorrelated or negatively correlated assets to reduce portfolio volatility and drawdown.

### Python Implementation Code

Below is a simplified representation of how you might integrate these techniques into your existing system:

```python
import numpy as np
from sklearn.ensemble import RandomForestClassifier

# Example: Adaptive Leverage Control
def adaptive_leverage(volatility, base_leverage=2.0, target_vol=0.15):
    """
    Adjust leverage based on current market volatility.
    """
    return min(base_leverage, target_vol / volatility)

# Example: Machine Learning for Regime Detection
def train_regime_classifier(features, labels):
    """
    Train a random forest classifier for regime detection.
    """
    clf = RandomForestClassifier(n_estimators=100, random_state=42)
    clf.fit(features, labels)
    return clf

def predict_regime(clf, features):
    """
    Predict market regime using the trained classifier.
    """
    return clf.predict(features)

# Example: Portfolio Adjustment
def adjust_portfolio(positions, predicted_regime, leverage):
    """
    Adjust positions based on predicted regime and leverage.
    """
    if predicted_regime == 'bear':
        positions *= 0.5  # Reduce risk exposure
    positions *= leverage
    return positions

# Simulating the effects
def simulate_strategy(market_data, model, base_leverage=2.0):
    """
    Simulates the trading strategy with leverage and regime detection.
    """
    vol = market_data['volatility']
    features = market_data['features']
    
    # Adaptive leverage
    leverage = adaptive_leverage(vol)
    
    # Regime prediction
    predicted_regime = predict_regime(model, features)
    
    # Adjust positions
    positions = market_data['positions']
    adjusted_positions = adjust_portfolio(positions, predicted_regime, leverage)
    
    return adjusted_positions

# Assuming market_data is a DataFrame with necessary columns
# Assuming model is a trained RandomForestClassifier
# adjusted_positions = simulate_strategy(market_data, model)
```

### Expected Performance Improvement Estimates

- **Reduced MDD**: By capping leverage during high volatility and improving regime detection, expect MDD to decrease to -10% or better.
- **Sharpe Ratio**: With better risk control, Sharpe ratio is likely to be maintained or improve slightly due to reduced volatility.
- **Annualized Return**: While there might be some reduction in return due to lower leverage in volatile times, the impact should be minimal if executed correctly.

These techniques, when integrated correctly, should help achieve the primary goal of reducing MDD while meeting secondary objectives. As always, thorough backtesting and validation against out-of-sample data are crucial to ensure robustness.